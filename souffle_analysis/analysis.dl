#include "analysis-input.dl"
#include "analysis-patterns.dl"
#include "util-macros.dl"
#include "util-graph.dl"
#include "util-lists.dl"
#include "analysis-contexts.dl"
#include "analysis-dataflow.dl"
#include "analysis-infoflow.dl"

.init ctxProvider = ContextProvider
.init infoflow = InfoFlowAnalysis
.init dataflow = MayDepOnAnalysis

// follows: a unit depends on another one which is closer to the leaves of the tree
.decl followsStep(element: Element, previousElement: Element)
followsStep(dependent, independent) :-
    (
        absDD(dependent, independent);
        absTD(dependent, independent);
        absTT(dependent, independent);
        appDD(dependent, independent);
        appTD(dependent, independent);
        argument(dependent, independent, _);
        bind(dependent, _, independent);
        callProc(dependent, independent);
        condBind(dependent, independent, _);
        dataCase(dependent, independent, _);
        dataCase(dependent, _, independent);
        jump(dependent, independent);
        keyArgument(dependent, independent, _);
        mapType(dependent, _, independent);
        pickData(dependent, independent);
        pickProc(dependent, independent);
        plan(dependent, independent, _);
        procCase(dependent, independent, _);
        procCase(dependent, _, independent);
        save(dependent, _, independent);
        send(dependent, independent);
        event(dependent, independent)
    ).
.output followsStep

.decl follows(dependent: Element, independent: Element)
follows(dependent, independent) :- followsStep(dependent, independent).
follows(dependent, independent) :- followsStep(dependent, intermediate), follows(intermediate, independent).

.output follows

.decl possibleTransfer(transfer: Unit, argument: Unit, parameter: Unit, distance: number)
possibleTransfer(transfer, argument, parameter, cApp):-
    appDD(transfer, _),
    argument(transfer, argument, index),
    argument(absDDId, parameter, index),
    follows(transfer, absDDId),
    absDD(absDDId, _),
    cApp = count : {follows(transfer, intermediate), appDD(intermediate, _) ,follows(intermediate, absDDId)},
    cAbs = count : {follows(transfer, intermediate), absDD(intermediate, _) ,follows(intermediate, absDDId)},
    cApp = cAbs.

.decl notSmallestTransfer(transfer: Unit, argument: Unit, parameter: Unit)
notSmallestTransfer(transfer, argument, parameter) :-
    possibleTransfer(transfer, _, _, smallerDistance),
    possibleTransfer(transfer, argument, parameter, distance),
    smallerDistance < distance.

.decl transfer(transfer: Unit, argument: Unit, parameter: Unit)
transfer(transfer, argument, parameter) :-
    possibleTransfer(transfer, argument, parameter, _),
    !notSmallestTransfer(transfer, argument, parameter).

.output transfer

.decl planApp(unitId: Unit)
planApp(unitId):-
    appDD(unitId, _), plan(_, unitId, _).

planApp(unitId):-
    appTD(unitId, _), plan(_, unitId, _).

.output planApp

// Field contribution tracking

// pseudo-fields are either normal fields or map accesses (load/save)
// for maps with only one level of keys, e.g. Map ByStr20 Uint128
// with `unitId`, we keep track which access corresponds to this pseudofield
.decl pseudofield(unitId: Unit, baseField: symbol, mapKey: symbol)

pseudofield(unitId, baseField, "") :-
    (save(unitId, baseField, _) ; load(unitId, baseField)),
    // No keys, i.e. this is a "normal" field access
    !argument(unitId, _, _),

    // This is needed so we do not consider field accesses that happen
    // during contract initialization
    transition(transitionId, _),
    follows(transitionId, unitId).

// Accesses where the key is a transition argument
pseudofield(unitId, baseField, mapKey) :-
    (save(unitId, baseField, _) ; load(unitId, baseField)),
    transition(transitionId, transitionName),
    follows(transitionId, unitId),

    // Just one key accessed in this map
    num_args = count : {
       argument(unitId, _, _)
    },
    num_args = 1,

    argument(unitId, argumentId, _),
    argument(transitionId, argumentId, argIndex),

    mapKey = cat(cat(transitionName, "."), to_string(argIndex)).

.output pseudofield

// builtin tracking
.decl fieldOps(transitionName: symbol, baseField: symbol, mapKey: symbol, builtinName: symbol)
fieldOps(transitionName, baseField, mapKey, builtinName) :-
    transition(transitionId, transitionName),
    follows(transitionId, saveId),
    save(saveId, baseField, _),
    appDD(appDDId, _),
    follows(saveId, appDDId),
    builtin(builtinId, _, builtinName),
    follows(appDDId, builtinId),
    // populate mapKey when the save is to a pseudofield; "" if not
    pseudofield(saveId, baseField, mapKey).

.output fieldOps

// field contributions
.decl fieldContribFieldCount(saveId: Unit, transitionName: symbol, fieldName: symbol, fieldKey: symbol, contributorName: symbol, c: number)
fieldContribFieldCount(saveId, transitionName, fieldName, fieldKey, contributorName, c) :-
    transition(transitionId, transitionName),
    follows(transitionId, saveId),

    save(saveId, fieldName, _),
    load(_, contributorName),

    // populate mapKey
    pseudofield(saveId, fieldName, fieldKey),

    // Implementation detail: fieldContribFieldCount can return multiple
    // counts for a given (trans, fn, fk, cn) tuple IF there is more than
    // one save to that field, since we technically count dependencies
    // per *save*, not per field
    c = count : {
        // Find load our save depends on
        load(loadId, contributorName),
        follows(saveId, loadId),

        // Count how many uses of that load we depend on
        follows(saveId, loadUserId),
        followsStep(loadUserId, loadId)
    }.

.output fieldContribFieldCount

// The implementation detail described above, combined with Datalog's
// stratification limitations, forces us to do some "manual" stratification
// so we don't get both "One" and "Many" results for the same field
.decl _fieldContribField(transitionName: symbol, fieldName: symbol, fieldKey: symbol, contributorName: symbol, card: Cardinality)
_fieldContribField(transitionName, fieldName, fieldKey, contributorName, "One") :-
    c = 1,
    fieldContribFieldCount(_, transitionName, fieldName, fieldKey, contributorName, c).

_fieldContribField(transitionName, fieldName, fieldKey, contributorName, "Many") :-
    c >= 2,
    fieldContribFieldCount(_, transitionName, fieldName, fieldKey, contributorName, c).


.decl fieldContribField(transitionName: symbol, fieldName: symbol, fieldKey: symbol, contributorName: symbol, card: Cardinality)
fieldContribField(transitionName, fieldName, fieldKey, contributorName, "One") :-
    _fieldContribField(transitionName, fieldName, fieldKey, contributorName, "One"),
    !_fieldContribField(transitionName, fieldName, fieldKey, contributorName, "Many").

fieldContribField(transitionName, fieldName, fieldKey, contributorName, "Many") :-
    _fieldContribField(transitionName, fieldName, fieldKey, contributorName, "Many").

.output fieldContribField

// transition argument contributions
.decl fieldContribArgCount(transitionName: symbol, fieldName: symbol, fieldKey: symbol, transArg: symbol, argIndex: number, c: number)
fieldContribArgCount(transitionName, fieldName, fieldKey, transArg, argIndex, c) :-
    transition(transitionId, transitionName),
    follows(transitionId, saveId),
    save(saveId, fieldName, _),
    argument(transitionId, argumentId, argIndex),

    // There are two ways an argument can be used:
    // 1) directly, e.g. field := arg
    // 2) indirectly, e.g. field := q, where q depends on arg
    // This contrasts with field reads, which can only be used indirectly,
    // i.e. field1 := field2 does not typecheck

    // This will always be either 0 or 1
    direct_uses = count : {
        // argumentID is the Data of the save
        followsStep(saveId, argumentId)
    },

    indirect_uses = count : {
        follows(saveId, argumentUserId),
        followsStep(argumentUserId, argumentId)
    },

    // FIXME: having the following line seems to not produce any output
    //  when direct_uses is 0; this is possibly a BUG in Souffle
    // c != 0,
    c = direct_uses + indirect_uses,

    // populate fieldKey and transArg
    pseudofield(saveId, fieldName, fieldKey),
    transArg = cat(cat(transitionName, "."), to_string(argIndex)).

.output fieldContribArgCount

.decl _fieldContribArg(transitionName: symbol, fieldName: symbol, fieldKey: symbol, transArg: symbol, argIndex: number, card: Cardinality)
_fieldContribArg(transitionName, fieldName, fieldKey, transArg, argIndex, "One") :-
    c = 1,
    fieldContribArgCount(transitionName, fieldName, fieldKey, transArg, argIndex, c).

_fieldContribArg(transitionName, fieldName, fieldKey, transArg, argIndex, "Many") :-
    c >= 2,
    fieldContribArgCount(transitionName, fieldName, fieldKey, transArg, argIndex, c).

.decl fieldContribArg(transitionName: symbol, fieldName: symbol, fieldKey: symbol, transArg: symbol, argIndex: number, card: Cardinality)
fieldContribArg(transitionName, fieldName, fieldKey, transArg, argIndex, "One") :-
    _fieldContribArg(transitionName, fieldName, fieldKey, transArg, argIndex, "One"),
    !_fieldContribArg(transitionName, fieldName,fieldKey, transArg, argIndex, "Many").

fieldContribArg(transitionName, fieldName, fieldKey, transArg, argIndex, "Many") :-
    _fieldContribArg(transitionName, fieldName, fieldKey, transArg, argIndex, "Many").

.output fieldContribArg
